/**
 * Copyright 2020 Appvia Ltd <info@appvia.io>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package kev

import (
	"context"
	"fmt"
	"os"
	"path"
	"path/filepath"
	"strings"
	"time"

	"github.com/appvia/kev/pkg/kev/config"
	"github.com/appvia/kev/pkg/kev/converter"
	"github.com/appvia/kev/pkg/kev/log"
	"github.com/appvia/kev/pkg/kev/terminal"
	"github.com/fsnotify/fsnotify"
	"github.com/mitchellh/go-wordwrap"
	"github.com/pkg/errors"
)

const (
	// SandboxEnv is a default environment name
	SandboxEnv = "dev"
)

var (
	// ManifestFilename is a name of main application manifest file
	ManifestFilename    = "kev.yaml"
	SecretsReferenceUrl = "https://github.com/appvia/kev/blob/master/docs/reference/config-params.md#reference-k8s-secret-key-value"
)

type Presentable struct {
	UI terminal.UI `yaml:"-" json:"-"`
}

func (p *Presentable) humanize(err error) string {
	if err == nil {
		return ""
	}
	return wordwrap.WrapString(err.Error(), 80)
}

type Project struct {
	workingDir string
	manifest   *Manifest
	*Presentable
}

func newProject(workingDir string, ui terminal.UI) *Project {
	return &Project{workingDir: workingDir, Presentable: &Presentable{UI: ui}}
}

func InitProjectWithOptions(workingDir string, ui terminal.UI, opts InitOptions) error {
	project := newProject(workingDir, ui)

	results, err := project.InitWithOptions(opts)
	if err != nil {
		printInitProjectWithOptionsError(ui)
		return err
	}

	if err := results.Write(); err != nil {
		printInitProjectWithOptionsError(ui)
		return err
	}

	printInitProjectWithOptionsSuccess(ui, project.manifest.Environments)
	return nil
}

func printInitProjectWithOptionsError(ui terminal.UI) {
	ui.Output("")
	ui.Output("Project had errors during initialisation.\n"+
		fmt.Sprintf("'%s' experienced some errors during project initialisation. The output\n", GetManifestName())+
		"above should contain the failure messages. Please correct these errors and\n"+
		fmt.Sprintf("run '%s init' again.", GetManifestName()),
		terminal.WithErrorBoldStyle(),
		terminal.WithIndentChar(terminal.ErrorIndentChar),
	)
}

func printInitProjectWithOptionsSuccess(ui terminal.UI, envs Environments) {
	ui.Output("")
	ui.Output("Project initialised!", terminal.WithStyle(terminal.SuccessBoldStyle))
	ui.Output(fmt.Sprintf("A '%s' file was created. Do not edit this file.\n", ManifestFilename)+
		"It syncs your deployment environments to updates made \n"+
		"to your compose sources.",
		terminal.WithStyle(terminal.SuccessStyle),
	)
	var namedValues []terminal.NamedValue
	for _, env := range envs {
		namedValues = append(namedValues, terminal.NamedValue{Name: env.Name, Value: env.File})
	}
	ui.Output("")
	ui.Output("And, the following deployment env files have been created:", terminal.WithStyle(terminal.SuccessStyle))
	ui.NamedValues(namedValues, terminal.WithStyle(terminal.SuccessStyle))
	ui.Output("")
	ui.Output("Update these to configure your deployments per related environment.", terminal.WithStyle(terminal.SuccessStyle))
	ui.Output("")
	ui.Output(fmt.Sprintf("You may now call `%s render` to prepare your project for deployment.", GetManifestName()))
}

func (p *Project) InitWithOptions(opts InitOptions) (WritableResults, error) {
	var skManifest *SkaffoldManifest

	if err := p.EnsureFirstInit(); err != nil {
		return nil, err
	}

	sources, err := p.DetectSources(opts)
	if err != nil {
		return nil, err
	}

	if err := p.ValidateSources(sources, config.SecretMatchers); err != nil {
		return nil, err
	}

	if err := p.CreateManifestAndDeployments(sources, opts); err != nil {
		return nil, err
	}

	p.UI.Header("Detecting Skaffold settings...")
	if opts.Skaffold {
		if skManifest, err = p.CreateOrUpdateSkaffoldManifest(); err != nil {
			return nil, err
		}
	} else {
		p.UI.Output("Skipping - no Skaffold options detected")
	}

	return createInitWritableResults(p.workingDir, p.manifest, skManifest), nil
}

func (p *Project) EnsureFirstInit() error {
	p.UI.Header("Verifying project...")
	sg := p.UI.StepGroup()
	defer sg.Done()
	s := sg.Add("Ensuring this project has not already been initialised")

	manifestPath := path.Join(p.workingDir, ManifestFilename)
	if ManifestExistsForPath(manifestPath) {
		absWd, _ := filepath.Abs(p.workingDir)
		err := fmt.Errorf("%s already exists at: %s", ManifestFilename, absWd)
		initStepError(p.UI, s, initStepConfig, err)
		return err
	}

	s.Success(time.Second * 1)
	return nil
}

func (p *Project) DetectSources(opts InitOptions) (*Sources, error) {
	p.UI.Header("Detecting compose sources...")

	sg := p.UI.StepGroup()
	defer sg.Done()
	if len(opts.ComposeSources) > 0 {
		for _, source := range opts.ComposeSources {
			s := sg.Add(fmt.Sprintf("Scanning for: %s", source))

			if !fileExists(source) {
				err := fmt.Errorf("cannot find compose source %q", source)
				initStepError(p.UI, s, initStepComposeSource, err)
				return nil, err
			}

			s.Success(time.Second*1, "Using: ", source)
		}

		return &Sources{Files: opts.ComposeSources}, nil
	}

	s := sg.Add(fmt.Sprintf("Scanning for compose configuration"))
	defaults, err := findDefaultComposeFiles(p.workingDir)
	if err != nil {
		initStepError(p.UI, s, initStepComposeSource, err)
		return nil, err
	}
	s.Success(time.Second * 1)
	for _, source := range defaults {
		s := sg.Add(fmt.Sprintf("Using: %s", source))
		s.Success(time.Second * 1)
	}

	return &Sources{Files: defaults}, nil
}

func (p *Project) ValidateSources(sources *Sources, matchers []map[string]string) error {
	p.UI.Header("Validating compose sources...")
	sg := p.UI.StepGroup()
	defer sg.Done()

	var secretsDetected bool
	for _, composeFile := range sources.Files {
		p.UI.Output(fmt.Sprintf("Detecting secrets in: %s", composeFile))
		composeProject, err := NewComposeProject([]string{composeFile})
		if err != nil {
			return err
		}

		for _, s := range composeProject.Services {
			step := sg.Add(fmt.Sprintf("Analysing service: %s", s.Name))
			serviceConfig := ServiceConfig{Name: s.Name, Environment: s.Environment}

			hits := serviceConfig.detectSecretsInEnvVars(matchers)
			if len(hits) == 0 {
				step.Success(time.Second*1, "Non detected in service: ", s.Name)
				continue
			}

			secretsDetected = true
			step.Warning(time.Second*1, "Detected in service: ", s.Name)
			for _, hit := range hits {
				p.UI.Output(
					fmt.Sprintf("env var [%s] - %s", hit.envVar, hit.description),
					terminal.WithStyle(terminal.LogStyle),
					terminal.WithIndentChar(terminal.LogIndentChar),
					terminal.WithIndent(3),
				)
			}
		}
	}

	if secretsDetected {
		p.UI.Output("")
		p.UI.Output("Validation successful!")
		p.UI.Output(fmt.Sprintf(`However, to prevent secrets leaking, see help page:
%s`, SecretsReferenceUrl))
	}

	return nil
}

func (p *Project) CreateManifestAndDeployments(sources *Sources, opts InitOptions) error {
	p.manifest = NewNewManifest(sources)
	p.manifest.Presentable = p.Presentable

	if _, err := p.manifest.CalculateSourcesBaseOverride(); err != nil {
		return err
	}

	p.manifest.MintEnvironments(opts.Envs)
	return nil
}

func (p *Project) CreateOrUpdateSkaffoldManifest() (*SkaffoldManifest, error) {
	var err error
	var skManifest *SkaffoldManifest

	sg := p.UI.StepGroup()
	defer sg.Done()

	composeProject, err := p.manifest.SourcesToComposeProject()
	if err != nil {
		return nil, err
	}

	skPath := path.Join(p.workingDir, SkaffoldFileName)
	envs := p.manifest.GetEnvironmentsNames()
	switch ManifestExistsForPath(skPath) {
	case true:
		updateStep := sg.Add(fmt.Sprintf("Adding deployment environments to existing Skaffold config: %s", skPath))
		// Skaffold manifest already present - add additional profiles to it!
		// Note: kev will skip profiles with names matching those of existing
		// profile names defined in Skaffold to avoid profile "hijack".
		if skManifest, err = AddProfiles(skPath, envs, true); err != nil {
			return nil, err
		}
		updateStep.Success(time.Second * 1)
	case false:
		createStep := sg.Add(fmt.Sprintf("Creating Skaffold config with deployment environments at: %s", skPath))
		if skManifest, err = NewSkaffoldManifest(envs, composeProject); err != nil {
			return nil, err
		}
		createStep.Success(time.Second * 1)
	}

	p.manifest.Skaffold = SkaffoldFileName
	return skManifest, nil
}

func createInitWritableResults(workingDir string, manifest *Manifest, skManifest *SkaffoldManifest) WritableResults {
	var out []WritableResult
	out = append(out, WritableResult{
		WriterTo: manifest,
		FilePath: path.Join(workingDir, ManifestFilename),
	})
	out = append(out, manifest.Environments.toWritableResults()...)

	if skManifest != nil {
		out = append(out, WritableResult{
			WriterTo: skManifest,
			FilePath: path.Join(workingDir, SkaffoldFileName),
		})
	}
	return out
}

// InitBase initialises a kev manifest including source compose files and environments.
// If no composeSources are provided, the working directory is introspected for valid compose files to act as sources.
// Also, an implicit sandbox environment will always be created.
func InitBase(workingDir string, composeSources, envs []string) (*Manifest, error) {
	if err := EnsureFirstInit(workingDir); err != nil {
		return nil, err
	}

	m, err := NewManifest(composeSources, workingDir)
	if err != nil {
		return nil, err
	}

	if _, err := m.CalculateSourcesBaseOverride(); err != nil {
		return nil, err
	}

	return m.MintEnvironments(envs), nil
}

func initStepError(ui terminal.UI, s terminal.Step, step initStepType, err error) {
	stepStrings := initStepStrings[step]
	s.Error(time.Second*1, stepStrings.Error)
	// s.Error(time.Second * 5)
	ui.Output("")
	if v := stepStrings.ErrorDetails; v != "" {
		ui.Output(strings.TrimSpace(v), terminal.WithErrorStyle(), terminal.WithIndentChar(terminal.ErrorIndentChar))
		ui.Output("")
	}
	ui.Output(humanize(err), terminal.WithErrorStyle(), terminal.WithIndentChar(terminal.ErrorIndentChar))
}

func humanize(err error) string {
	if err == nil {
		return ""
	}
	return wordwrap.WrapString(err.Error(), 80)
}

type initStepType uint

const (
	initStepConfig initStepType = iota
	initStepComposeSource
	initStepConnect
	initStepParsingComposeConfig
	initStepPluginConfig
	initStepProject
	initStepAuth
)

var initStepStrings = map[initStepType]struct {
	Error        string
	ErrorDetails string
	Other        map[string]string
}{
	initStepConfig: {
		Error: "This project has already been initialised!",
	},

	initStepComposeSource: {
		Error: "Missing compose source file!",
		ErrorDetails: `
At least a single compose file and zero or more compose override files 
are required. These are used to initialise a project and to setup 
deployment environments. Without them a project cannot be initialised. 
		`,
	},

	initStepParsingComposeConfig: {
		Error: "Invalid compose source(s)!",
		ErrorDetails: `
The provided compose source or sources are invalid. 'kev' requires valid 
compose source files - without them a project cannot be initialised. 
Use the command 'docker-compose -f <compose-source-file> config'
to double check your compose source(s) are valid.
		`,
	},

	initStepConnect: {
		Error: "Failed to initialize client for Waypoint server.",
		ErrorDetails: `
The Waypoint client validation step validates that we can connect to the
configured Waypoint server. If this is a local-only operation (no Waypoint
server is configured), then we validate that we can initialize local writes.
The error for this failure is shown below.
			`,
	},

	initStepPluginConfig: {
		Error: "Failed to load and validate plugins!",
		ErrorDetails: `
This validation check ensures that you have all the required plugins available
and the configuration for each plugin (if it exists) is valid. The error message
below should tell you which plugin(s) failed.
		`,
	},

	initStepProject: {
		Error: "Error while checking for project registration.",
		ErrorDetails: `
There was an error while the checking if the project and applications
are registered with the Waypoint server. This error may be temporary and
you may retry to init. See the error message below.
		`,

		Other: map[string]string{
			"unregistered-desc": `
The project and apps must be registered prior to performing any operations.
This creates some metadata with the server. We require registration as a
verification that the project/app names are correct and that you're targeting
the correct server.
			`,
		},
	},

	initStepAuth: {
		Error: "Failed to check authentication requirements!",
		ErrorDetails: `
This step verifies that Waypoint has access to the configured systems.
This is a best-effort check, since not all plugins support this check
and the check can often only check that any known credentials work at
a minimal level.
There was an error during this step and it is shown below.
		`,

		Other: map[string]string{
			"guide": `
Waypoint will guide you through the authentication process one plugin
at a time. Plugins may interactively attempt to authenticate or they may
just output help text to guide you there. You can use Ctrl-C at any point
to cancel and run "waypoint init" again later.
			`,

			"auth-failure": `
Authentication failed with error: %s
			`,
		},
	},
}

// Reconcile reconciles changes with docker-compose sources against deployment environments.
func Reconcile(workingDir string) (*Manifest, error) {
	m, err := LoadManifest(workingDir)
	if err != nil {
		return nil, err
	}
	if _, err := m.ReconcileConfig(); err != nil {
		return nil, errors.Wrap(err, "Could not reconcile project latest")
	}
	return m, err
}

// DetectSecrets detects any potential secrets defined in environment variables
// found either in sources or override environments.
// Any detected secrets are logged using a warning log level.
func DetectSecrets(workingDir string) error {
	m, err := LoadManifest(workingDir)
	if err != nil {
		return err
	}

	if err := m.DetectSecretsInSources(config.SecretMatchers); err != nil {
		return err
	}
	if err := m.DetectSecretsInEnvs(config.SecretMatchers); err != nil {
		return err
	}
	return nil
}

// Render renders k8s manifests for a kev app. It returns an app definition with rendered manifest info
// It takes optional exclusion list as map of environment name to a slice of excluded docker compose service names.
func Render(workingDir string, format string, singleFile bool, dir string, envs []string, excluded map[string][]string) error {
	manifest, err := LoadManifest(workingDir)
	if err != nil {
		return errors.Wrap(err, "Unable to load app manifest")
	}

	_, err = manifest.RenderWithConvertor(converter.Factory(format), dir, singleFile, envs, excluded)
	return err
}

// Watch continuously watches source compose files & environment overrides and notifies changes to a channel
func Watch(workDir string, change chan<- string) error {
	manifest, err := LoadManifest(workDir)
	if err != nil {
		log.Errorf("Unable to load app manifest - %s", err)
		os.Exit(1)
	}

	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Fatal(err)
		return err
	}
	defer watcher.Close()

	done := make(chan bool)

	go func() {
		for {
			select {
			case event, ok := <-watcher.Events:
				if !ok {
					return
				}

				if event.Op&fsnotify.Write == fsnotify.Write {
					change <- event.Name
				}
			case err, ok := <-watcher.Errors:
				if !ok {
					return
				}

				log.Error(err)
			}
		}
	}()

	files := manifest.GetSourcesFiles()
	filteredEnvs, err := manifest.GetEnvironments([]string{})
	for _, e := range filteredEnvs {
		files = append(files, e.File)
	}

	for _, f := range files {
		err = watcher.Add(f)
		if err != nil {
			return err
		}
	}

	<-done

	return nil
}

// Dev contains dev command business logic
func Dev(opts *DevOptions, workDir string, preRunCommands []RunFunc, errHandler ErrorHandler, changeHandler ChangeHandler) error {

	runPreCommands := func() error {
		for _, preRunCmd := range preRunCommands {
			if err := preRunCmd(); err != nil {
				return err
			}
		}
		return nil
	}

	change := make(chan string, 50)
	defer close(change)

	// initial manifests generation for specified environments only
	if err := runPreCommands(); err != nil {
		return errHandler(err)
	}

	if opts.Skaffold {
		ctx, cancel := context.WithCancel(context.Background())
		defer cancel()

		catchCtrlC(cancel)

		skaffoldConfigPath, skaffoldConfig, err := ActivateSkaffoldDevLoop(workDir)
		if err != nil {
			return errHandler(err)
		}

		if err := WriteTo(skaffoldConfigPath, skaffoldConfig); err != nil {
			return errHandler(errors.Wrap(err, "Couldn't write Skaffold config"))
		}

		profileName := opts.Kevenv + EnvProfileNameSuffix
		go RunSkaffoldDev(ctx, os.Stdout, skaffoldConfigPath, []string{profileName}, opts)
	}

	go Watch(workDir, change)

	for {
		ch := <-change
		if len(ch) > 0 {
			fmt.Printf("\n♻️  %s changed! Re-rendering manifests...\n\n", ch)

			if changeHandler != nil {
				changeHandler(ch)
			}

			if err := runPreCommands(); err != nil {
				errHandler(err)
			}

			// empty the buffer as we only ever do one re-render cycle per a batch of changes
			if len(change) > 0 {
				for range change {
					if len(change) == 0 {
						break
					}
				}
			}
		}
	}
}
